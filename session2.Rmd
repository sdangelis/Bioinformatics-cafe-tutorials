---
title: "session 2"
---

Work in progress! please come back later.
the outline here refers to the plan for session 2.

```{r}
library(tidyverse)
library(docstring)
```


Welcome to day 2! Today we'll introduce some powerful programming concepts and use tidy R to analyse the results of a cell biology experiment.

## Custom functions and control flow

### Control flow 


Before we 

# Creating custom functions 

So far, if we needed to 

A powerful

note that w 
```{r}
```

R by default returns the last item evaluated. sometimes it si 

## docstring


we could add a comment to the function to describe what the function does but this will not be actually associated with the function when we call it or 
appear if we use `?my_function`

The package docstring allows us to generate documentation for any function on the fly, borrowing from 
```{r}
sum3 <- function(x, y){
  #' Sums two numbers
  #' 
  #' @param x the first number to sum
  #' @param y the second number to sum
  #' @return the sum of \code{x} and \code{y
  #' @example 
  #' sum(2,2)
  x+y
} 
```

note `#'` is mandatory. We can use tags from [Roxygen2](https://roxygen2.r-lib.org/articles/rd.html) to structure our documentation.
There are lots of tags, some useful ones are 

- @param argument description` to specify the description of arguments
- @return to specify what the function returns 
- @examples r code that provides an example for how to use a function. this will run so it has to be either valid R code or wrapped in a `\dontrun{code}` block
- @note to add a note
- @references to add a citation to your function

# Loops 

there are 3 types of loops in R: for while and repeat. Most of the time we can use while or for loops but  

## for loops 

for loops repeat the expression n times. we can access tjh
```{r}
for(i in 1:10){
  print(i)
}
```

Conventionally the counter for loops is `i`, in case of nested loops `i` is taken for the first loop so we  can use `j` in the second loop and so on.

## While

While loops repeat a code block until a certain condition is met, for instance we can count to 10 by printing. Note when working in a while loop we need to
manually increment the counter and make sure the exit condition makes sense, else our loop will run literally forever
```{r}
count=1
while (count<11){
  print(count)
  count = count+1 
}
```



## Repeat

Repeat loops are similar to while loops but execute once then use a break statement to exit the loop
once we met our condition.
```{r}
x=0
repeat {
  print(x)
  x = x+1
  if (x == 11){
    break
  }}
```


the `break` statement to quit a loop early work in all kinds of loops
similarly `next` skips the current iteration 

# Apply functions

A generally preferred alternative to loops. Despite common belief this is not necessarily faster than a loop^[see Advanced R and the R inferno].

## Anonymous functions

The apply family of functions becomes very powerful when coupled with anonymous functions.
Anonymous functions are functions that have no name 
we can create an anonymous function with 
`funtion(x) { function body }`

The purr package additionally provides some more

## A note on performance and vectorisation 

As you might have noticed our loop to multiply a vector by a number is much slower than using `*`. 
R is a vectorised which means operations on a whole vector are much faster than the sum of each individual operations on each element.^[This is not black magic, vectorised functions loop over items in C rather than R. C has less overhead so is faster.]

Nonetheless, loops are quick (but not fast), dirty and can get the job done.
there are some tricks to make sure loops run as fast as they can
1. Never grow a variable inside a loop 

it is tempting to write a loop where we grow a variable by 1 in each iteration. For instance in this loop we sample
from a normal distribution n times and return all the variables. 
Note the `rnorm()` function here is just an example of something that runs at each iteration,
if we want to sample n elements from a normal distribution we can and should use `rmorm(n)`

```{r}
bad_loop <- function (n){
  x = NA
  for(i in 1:n){
    x <- c(x, rnorm(1)) 
  }
  return(x)
}
```
however, every time we grow the variable we force R to copy the vector to a new memory location with more space, consuming time

Our loop will be much faster if we create a vector of the right size first and then replace values as we go along.^[note depending on what kind of object x is, using x[i] might still duplicate it]
```{r}
good_loop <- function(n){
  x <- rep(NA,n)
  for(i in 1:n){
    x[i] <- rnorm(1) 
  }
  return(x)
}
```

We can use the `system.time()` function to quickly check how fast is our code.
```{r}
system.time(good_loop(1e5))
system.time(bad_loop(1e5))
```
Compared to the more optimised loop, the bad loop is unreasonably slow. The Rstudio Built in profiler reveals that the bad loop spends most of the time in the `c()` rather than `rmorm()`

2. keep an eye on assignments

The sharper eyes noted that the bad loop first creates a new vector with the old array and new value, then grows the old array. We can remove this extra step. In general keep an eye on unnecessary assignments in loops as they can be costly.
```{r}
less_bad_loop <- function (n){
  x = NA
  for(i in 1:n){
    x[i] <- rnorm(1) 
  }
  return(x)
}
```

We can now compare the two loops again.
```{r}
system.time(good_loop(1e5))
system.time(less_bad_loop(1e5))
```

Now the difference is much smaller but still noticeable. For more performance tricks,
see the [R Inferno book]

# Into the tidyverse 

By now we have all the tools we need to use R effectively

## manipulating data frames effectively



## one pipe, two pipes

pipes reside in the magrittr package but are implicitly imported by tidy packages
a pipe connects the output from a function to another, without the need to assign it to a variable


if you are on R >= 4.1 pipes are now part of base r `|>` will get you a pipe. it works like `%>%` but has no support for the `.` placeholder

## dyplr 

## string manipulation 

## ggplot2

### scatterplot

### histogram

### boxplot 

### violin plot

### dotplot

## colour palettes 

While the ggplot default palette is somewhat iconic, colours from the viridis package are a good starting point to choose colours. They are designed accessible to people with colourblindness, legible in grayscale and be perceptually uniform so each colour has a uniform distance from the next colour.


for base plots we need to separately generate a viridis colour palette.

in ggplot2 based graphics we can use the `scale_fill_viridis()` and `scale_color_viridis()` 
in our plot as needed.

But if we feel more artsy, we can pick colour palettes from everything, from [Wes Anderson movies](https://github.com/karthik/wesanderson)
to [Stuido Ghibli Films](https://github.com/ewenme/ghibli). For a comprehensive list see the [paletteer ](https://github.com/EmilHvitfeldt/r-color-palettes) package.


